const interactiveScript = () => {  const root = document.getElementById('p10-lab');  if (!root) return;  const scenarioButtonsEl = document.getElementById('p10-scenarios');  const stageHeadingEl = document.getElementById('p10-stage-heading');  const stageSubheadingEl = document.getElementById('p10-stage-subheading');  const stageLabelEl = document.getElementById('p10-stage-label');  const stageControlsEl = document.getElementById('p10-stage-controls');  const allocationEl = document.getElementById('p10-allocation');  const actionsEl = document.getElementById('p10-actions');  const SCENARIOS = {    pre: {      label: 'Before AI',      heading: 'Where scarce experts step in before AI',      subheading: 'Experts cover the edge of the playbook while routine teams handle the familiar core.',      actions: (metrics) => [        `Keep expert attention on ${metrics.expertBand || 'the hardest tickets'} where scripted teams stall.`,        `Expand playbooks to trim the ${metrics.unansweredShare} of requests that no team can absorb yet.`      ]    },    short: {      label: 'Short-run AI impact',      heading: 'After AI copilots arrive',      subheading: 'Humans stay on the toughest requests while AI fills the middle bands they used to babysit.',      actions: (metrics) => [        `Point AI copilots at ${metrics.aiBand || 'mid-band work'} so experts can stay focused on ${metrics.expertBand || 'the frontier cases'}.`,        `Use the breathing room while routine teams still cover ${metrics.routineShare} to plan reskilling and new roles.`      ]    },    long: {      label: 'Long-run AI impact',      heading: 'Long-run rebalance with abundant AI',      subheading: 'Routing is rebuilt so AI handles most repeatable work; humans remain on the true edge cases.',      actions: (metrics) => [        `Launch redeployment plans before routine work drops to ${metrics.routineShare}.`,        `Keep safeguards so humans retain ${metrics.expertBand || 'the trickiest band'} for trust and judgement.`      ]    }  };  const state = {    scenario: 'pre',    q: 0.18,    eta: 1.2,    etaAI: 2.0,    LG: 0.12  };  const controls = {    sliders: {},    labels: {},    helper: null  };  let controlsRenderedFor = null;  const SAMPLE_POINTS = 400;  const STEP = 1 / SAMPLE_POINTS;  const X0 = 0.5;  const clamp = (value, min, max) => Math.min(Math.max(value, min), max);  const formatNumber = (value, decimals = 1) => (Number.isFinite(value) ? value.toFixed(decimals) : '0.0');  const formatPercent = (share) => `${formatNumber(share * 100, 1)}%`;  const describeBand = (entry) => {    if (!entry || !entry.range) return null;    const { min, max } = entry.range;    if (!Number.isFinite(min) || !Number.isFinite(max)) return null;    const minPct = formatNumber(min * 100, 0);    const maxPct = formatNumber(max * 100, 0);    if (Math.abs(maxPct - minPct) < 2) {      return `requests about ${maxPct}% away from the playbook`;    }    return `requests roughly ${minPct}%-${maxPct}% away from the playbook`;  };  const describePlaybookSetting = (value) => {    if (value < 0.12) return 'very tight, so routine teams escalate as soon as work drifts beyond the scripts';    if (value <= 0.20) return 'balanced, giving routine teams some breathing room before escalating';    return 'wide, so routine teams stay involved even when work strays';  };  const describeBenchCapacity = (value) => {    if (value < 0.15) return 'a small bench, so escalations pile up quickly';    if (value <= 0.25) return 'a mid-sized bench that can absorb some spikes';    return 'a deep bench that covers most edge cases';  };  const describeEffortCurve = (value, subject) => {    if (value <= 1) return subject + ' effort stays light even as cases get unfamiliar';    if (value <= 2) return subject + ' effort ramps steadily as issues get harder';    return subject + ' effort spikes quickly once work leaves the comfort zone';  };  const describeAiCurve = (value, scenario) => {    if (scenario === 'pre') {      return 'AI copilots are offline in this view, so any leftover work stays in the queue.';    }    if (value <= 1.5) return 'AI handles new situations with ease, making it a strong backfill for routine teams.';    if (value <= 3) return 'AI needs guidance on unfamiliar work, but it can still relieve pressure on experts.';    return 'AI still struggles with novel work, so humans shoulder most edge cases.';  };  const buildSliderNarrative = (state, scenario) => {    const playbookPct = formatNumber(state.q * 100, 0);    const benchPct = formatNumber(state.LG * 100, 0);    const playbookNote = describePlaybookSetting(state.q);    const benchNote = describeBenchCapacity(state.LG);    const expertEffortNote = describeEffortCurve(state.eta, 'Expert');    const aiEffortNote = describeAiCurve(state.etaAI, scenario);    const parts = [];    parts.push('<div class="mt-3 panel panel-neutral-soft p-3 text-xs space-y-2">');    parts.push('<p class="panel-muted"><strong>Playbook reach:</strong> ' + playbookPct + '% comfort zone - ' + playbookNote + '.</p>');    parts.push('<p class="panel-muted"><strong>Expert bench:</strong> ' + benchPct + '% capacity - ' + benchNote + '.</p>');    parts.push('<p><strong>Expert effort curve:</strong> ' + state.eta.toFixed(2) + ' - ' + expertEffortNote + '.</p>');    if (scenario === 'pre') {      parts.push('<p class="panel-muted"><strong>AI effort curve:</strong> ' + aiEffortNote + '</p>');    } else {      parts.push('<p class="panel-muted"><strong>AI effort curve:</strong> ' + state.etaAI.toFixed(2) + ' - ' + aiEffortNote + '.</p>');    }    parts.push('</div>');    return parts.join('');  };  const buildBaseGrid = (params) => {    const grid = [];    for (let i = 0; i < SAMPLE_POINTS; i += 1) {      const x = (i + 0.5) * STEP;      const d = Math.abs(x - X0);      const routineValue = d <= params.q ? 1 - (d / params.q) : 0;      const humanValue = Math.max(0, 1 - params.eta * d * d);      const aiValue = Math.max(0, 1 - params.etaAI * d * d);      grid.push({        index: i,        d,        weight: STEP,        routineValue,        humanValue,        aiValue,        advantage: humanValue - routineValue,        assignment: 'none'      });    }    return grid;  };  const allocatePreAI = (params) => {    const grid = buildBaseGrid(params);    const candidates = grid.filter((cell) => cell.advantage > 0 && cell.humanValue > 0).slice();    candidates.sort((a, b) => b.advantage - a.advantage);    let used = 0;    for (const cell of candidates) {      if (used + cell.weight > params.LG + 1e-6) break;      grid[cell.index].assignment = 'human';      used += cell.weight;    }    grid.forEach((cell) => {      if (cell.assignment === 'human') return;      if (cell.routineValue > 0) {        cell.assignment = 'routine';      } else {        cell.assignment = 'none';      }    });    return grid;  };  const allocateShortRun = (params) => {    const preGrid = allocatePreAI(params);    const grid = preGrid.map((cell) => ({ ...cell }));    const humanCells = grid.filter((cell) => cell.assignment === 'human');    humanCells.sort((a, b) => b.d - a.d);    let remaining = params.LG;    const keep = new Set();    for (const cell of humanCells) {      if (remaining <= 0) break;      keep.add(cell.index);      remaining -= cell.weight;    }    grid.forEach((cell) => {      if (cell.assignment === 'human') {        if (!keep.has(cell.index)) {          cell.assignment = cell.aiValue > 0 ? 'ai' : 'none';        }      } else if (cell.assignment === 'none' && cell.aiValue > 0) {        cell.assignment = 'ai';      }    });    return grid;  };  const allocateLongRun = (params) => {    const grid = buildBaseGrid(params);    const candidates = grid      .map((cell) => ({        ...cell,        bestOther: Math.max(cell.aiValue, cell.routineValue)      }))      .filter((cell) => cell.humanValue > cell.bestOther)      .sort((a, b) => (b.humanValue - b.bestOther) - (a.humanValue - a.bestOther));    let used = 0;    for (const cell of candidates) {      if (used + cell.weight > params.LG + 1e-6) break;      grid[cell.index].assignment = 'human';      used += cell.weight;    }    grid.forEach((cell) => {      if (cell.assignment === 'human') return;      if (cell.aiValue >= cell.routineValue && cell.aiValue > 0) {        cell.assignment = 'ai';      } else if (cell.routineValue > 0) {        cell.assignment = 'routine';      } else {        cell.assignment = 'none';      }    });    return grid;  };  const summariseGrid = (grid) => {    const summary = {      human: { share: 0, min: Infinity, max: -Infinity },      ai: { share: 0, min: Infinity, max: -Infinity },      routine: { share: 0, min: Infinity, max: -Infinity },      none: { share: 0, min: Infinity, max: -Infinity }    };    grid.forEach((cell) => {      const bucket = summary[cell.assignment] || summary.none;      bucket.share += cell.weight;      if (cell.d < bucket.min) bucket.min = cell.d;      if (cell.d > bucket.max) bucket.max = cell.d;    });    const cleanup = (entry) => {      if (entry.share <= 0) return null;      return {        share: clamp(entry.share, 0, 1),        range: {          min: Number.isFinite(entry.min) ? entry.min : null,          max: Number.isFinite(entry.max) ? entry.max : null        }      };    };    return {      human: cleanup(summary.human),      ai: cleanup(summary.ai),      routine: cleanup(summary.routine),      none: cleanup(summary.none)    };  };  const buildAllocationSummary = (stats) => {    const lines = [];    if (stats.human) {      lines.push(`<p><strong>Expert bench:</strong> ${formatPercent(stats.human.share)} of requests (${describeBand(stats.human) || 'reserved for edge cases'}).</p>`);    } else {      lines.push('<p><strong>Expert bench:</strong> Not involved under this setup.</p>');    }    if (stats.ai) {      lines.push(`<p><strong>AI copilots:</strong> ${formatPercent(stats.ai.share)} (${describeBand(stats.ai) || 'covering the mid-band work'}).</p>`);    } else {      lines.push('<p><strong>AI copilots:</strong> Not deployed here.</p>');    }    if (stats.routine) {      lines.push(`<p><strong>Routine teams:</strong> ${formatPercent(stats.routine.share)} handling work that stays inside the comfort zone.</p>`);    } else {      lines.push('<p><strong>Routine teams:</strong> No remaining workload in this scenario.</p>');    }    if (stats.none) {      lines.push(`<p><strong>Unserved:</strong> ${formatPercent(stats.none.share)} of requests still wait for coverage.</p>`);    }    return lines.join('');  };  const buildMetrics = (stats) => ({    expertBand: describeBand(stats.human),    aiBand: describeBand(stats.ai),    routineShare: stats.routine ? formatPercent(stats.routine.share) : '0.0%',    unansweredShare: stats.none ? formatPercent(stats.none.share) : '0.0%'  });  const updateStageLabelContent = () => {
  if (!stageLabelEl) return;
  stageLabelEl.innerHTML = '';
  stageLabelEl.classList.add('hidden');
};  const renderScenarioButtons = () => {    const buttons = Object.entries(SCENARIOS)      .map(([key, meta]) => {        const isActive = state.scenario === key;        const base = 'px-3 py-1.5 text-xs font-semibold rounded-full border transition-colors focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500';        const stateClass = isActive          ? 'bg-indigo-600 border-indigo-600 text-white shadow-sm'          : 'bg-card border-subtle text-body hover:border-indigo-400 hover:text-indigo-600';        return `<button type="button" data-scenario="${key}" class="${base} ${stateClass}">${meta.label}</button>`;      })      .join('');    scenarioButtonsEl.innerHTML = buttons;    scenarioButtonsEl.querySelectorAll('button').forEach((btn) => {      btn.addEventListener('click', () => {        const scenario = btn.getAttribute('data-scenario');        if (!scenario || !SCENARIOS[scenario]) return;        if (state.scenario === scenario) return;        state.scenario = scenario;        update();      });    });  };  const updateScenarioButtonStates = () => {    scenarioButtonsEl.querySelectorAll('button').forEach((btn) => {      const scenario = btn.getAttribute('data-scenario');      const isActive = state.scenario === scenario;      btn.classList.toggle('bg-indigo-600', isActive);      btn.classList.toggle('border-indigo-600', isActive);      btn.classList.toggle('text-white', isActive);      btn.classList.toggle('shadow-sm', isActive);      btn.classList.toggle('bg-card', !isActive);      btn.classList.toggle('border-subtle', !isActive);      btn.classList.toggle('text-body', !isActive);    });  };  const attachSliderHandlers = () => {    const { sliders } = controls;    if (sliders.playbook) {      sliders.playbook.addEventListener('input', (event) => {        const value = parseFloat(event.target.value);        if (!Number.isFinite(value)) return;        state.q = clamp(value, 0.05, 0.3);        update({ fromSlider: true });      });    }    if (sliders.expertCurve) {      sliders.expertCurve.addEventListener('input', (event) => {        const value = parseFloat(event.target.value);        if (!Number.isFinite(value)) return;        state.eta = clamp(value, 0.5, 4);        update({ fromSlider: true });      });    }    if (sliders.aiCurve) {      sliders.aiCurve.addEventListener('input', (event) => {        const value = parseFloat(event.target.value);        if (!Number.isFinite(value)) return;        state.etaAI = clamp(value, 0.8, 6);        update({ fromSlider: true });      });    }    if (sliders.expertCapacity) {      sliders.expertCapacity.addEventListener('input', (event) => {        const value = parseFloat(event.target.value);        if (!Number.isFinite(value)) return;        state.LG = clamp(value, 0.05, 0.4);        update({ fromSlider: true });      });    }  };  const updateControlDisplays = () => {    const { sliders, labels, helper } = controls;    if (labels.playbook) labels.playbook.textContent = `${formatNumber(state.q * 100, 0)}%`;    if (labels.expertCurve) labels.expertCurve.textContent = state.eta.toFixed(2);    if (labels.expertCapacity) labels.expertCapacity.textContent = `${formatNumber(state.LG * 100, 0)}%`;    if (labels.aiCurve) {      if (state.scenario === 'pre') {        labels.aiCurve.textContent = 'Off';      } else {        labels.aiCurve.textContent = state.etaAI.toFixed(2);      }    }    if (sliders.aiCurve) {      sliders.aiCurve.disabled = state.scenario === 'pre';      sliders.aiCurve.value = state.etaAI.toFixed(2);    }    if (sliders.playbook) sliders.playbook.value = state.q.toFixed(2);    if (sliders.expertCurve) sliders.expertCurve.value = state.eta.toFixed(2);    if (sliders.expertCapacity) sliders.expertCapacity.value = state.LG.toFixed(2);    if (helper) {      helper.textContent = state.scenario === 'pre'        ? 'AI copilots are disabled in this view. Switch to an AI scenario to tune them.'        : 'Adjust to see how fast AI effort ramps on unfamiliar work.';    }  };  const renderControls = () => {    if (controlsRenderedFor !== state.scenario) {      const isPre = state.scenario === 'pre';      stageControlsEl.innerHTML = `        <div class="panel panel-info p-3 space-y-2">          <label class="text-xs font-semibold text-heading uppercase" for="p10-q">Playbook comfort zone</label>          <input id="p10-q" type="range" min="0.05" max="0.30" step="0.01" value="${state.q.toFixed(2)}" class="w-full accent-indigo-600" />          <div class="flex items-center justify-between text-xs panel-muted">            <span>Narrow</span>            <span id="p10-q-value"></span>            <span>Wide</span>          </div>          <p class="text-xs panel-muted">How far routine teams can stretch before they escalate to experts.</p>        </div>        <div class="panel panel-info p-3 space-y-2">          <label class="text-xs font-semibold text-heading uppercase" for="p10-eta">Expert effort curve</label>          <input id="p10-eta" type="range" min="0.50" max="4.00" step="0.10" value="${state.eta.toFixed(2)}" class="w-full accent-indigo-600" />          <div class="flex items-center justify-between text-xs panel-muted">            <span>Stays manageable</span>            <span id="p10-eta-value"></span>            <span>Spikes quickly</span>          </div>          <p class="text-xs panel-muted">Higher values mean experts tire faster as issues get unfamiliar.</p>        </div>        <div class="panel panel-info p-3 space-y-2 ${isPre ? 'opacity-60' : ''}">          <label class="text-xs font-semibold text-heading uppercase" for="p10-etaai">AI effort curve</label>          <input id="p10-etaai" type="range" min="0.80" max="6.00" step="0.10" value="${state.etaAI.toFixed(2)}" class="w-full accent-indigo-600" ${isPre ? 'disabled' : ''} />          <div class="flex items-center justify-between text-xs panel-muted">            <span>Efficient</span>            <span id="p10-etaai-value"></span>            <span>Needs help</span>          </div>          <p id="p10-ai-helper" class="text-xs panel-muted"></p>        </div>        <div class="panel panel-info p-3 space-y-2">          <label class="text-xs font-semibold text-heading uppercase" for="p10-lg">Expert bench capacity</label>          <input id="p10-lg" type="range" min="0.05" max="0.40" step="0.01" value="${state.LG.toFixed(2)}" class="w-full accent-indigo-600" />          <div class="flex items-center justify-between text-xs panel-muted">            <span>Tiny bench</span>            <span id="p10-lg-value"></span>            <span>Plenty of experts</span>          </div>          <p class="text-xs panel-muted">Share of total requests your expert crew can realistically touch.</p>        </div>      `;      controls.sliders.playbook = document.getElementById('p10-q');      controls.sliders.expertCurve = document.getElementById('p10-eta');      controls.sliders.aiCurve = document.getElementById('p10-etaai');      controls.sliders.expertCapacity = document.getElementById('p10-lg');      controls.labels.playbook = document.getElementById('p10-q-value');      controls.labels.expertCurve = document.getElementById('p10-eta-value');      controls.labels.aiCurve = document.getElementById('p10-etaai-value');      controls.labels.expertCapacity = document.getElementById('p10-lg-value');      controls.helper = document.getElementById('p10-ai-helper');      attachSliderHandlers();      controlsRenderedFor = state.scenario;    }    updateControlDisplays();  };  const chooseGridByScenario = () => {    if (state.scenario === 'pre') return allocatePreAI(state);    if (state.scenario === 'short') return allocateShortRun(state);    return allocateLongRun(state);  };  const update = ({ fromSlider = false } = {}) => {    const scenarioMeta = SCENARIOS[state.scenario];    if (!scenarioMeta) return;    const grid = chooseGridByScenario();    const stats = summariseGrid(grid);    const metrics = buildMetrics(stats);    stageHeadingEl.textContent = scenarioMeta.heading;    stageSubheadingEl.textContent = scenarioMeta.subheading;    updateStageLabelContent(stats);    allocationEl.innerHTML = buildAllocationSummary(stats) + buildSliderNarrative(state, state.scenario);    const actions = scenarioMeta.actions(metrics) || [];    actionsEl.innerHTML = actions.map((text) => `<li>${text}</li>`).join('');    renderScenarioButtons();    updateScenarioButtonStates();    renderControls();  };  update();};if (typeof module !== 'undefined') {  module.exports = interactiveScript;} else if (typeof window !== 'undefined') {  window.interactiveScript = interactiveScript;}



